<canvas width="1200" height="800"></canvas>

<script>
	const $ = document.querySelector.bind(document);
	const cf = ({r, g, b, a = 1}) => `rgba(${r * 255}, ${g * 255}, ${b * 255}, ${a})`;
	const cfu = (v, a = 1) => `rgba(${v * 255}, ${v * 255}, ${v * 255}, ${a})`;
	const dist = (x, y, x2, y2) => Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);
	const scale = (v, min, max) => Math.min(Math.max((v - min) / (max - min), 0), 1);
	const fontHeight = ctx => ctx.measureText('M').width * .99;

	const LAYER_COUNT = 5;

	class Curves {
		constructor(width, height) {
			this.width = width;
			this.height = height;
			this.n = 4;
			this.layers = [];
			this.pressure = new Average(.3);
			this.listeners = [];
		}

		newLayer() {
			let canvas = document.createElement('canvas');
			canvas.width = this.width;
			canvas.height = this.height;
			let ctx = canvas.getContext('2d');

			return {
				canvas,
				ctx,
				curves: [],
			};
		}

		setColor(color) {
			this.color = color;
		}

		setLayer(layer) {
			this.layer = layer;
		}

		beginCurve() {
			this.layers[this.layer] = this.layers[this.layer] || this.newLayer();
			this.curve = {color: this.color, touches: []};
			this.pressure.reset();
			this.layers[this.layer].curves.push(this.curve);
		}

		continueCurve(touch) {
			this.curve.touches.push(touch);

			if (this.curve.touches.length < this.n)
				return;
			let ts = this.curve.touches.slice(this.curve.touches.length - this.n);

			let pressure = ts.reduce((a, {w, h}) => a + w + h, 0) / ts.length;
			let avgPressure = this.pressure.addValue(pressure);
			let scaledPressure = scale(avgPressure, 2, 3);
			let width = scaledPressure ** 2 * 10 + 1;

			let ctx = this.layers[this.layer].ctx;
			ctx.lineWidth = width;
			ctx.beginPath();
			ctx.moveTo(ts[0].x, ts[0].y);
			ctx.bezierCurveTo(ts[1].x, ts[1].y, ts[2].x, ts[2].y, ts[3].x, ts[3].y);
			ctx.strokeStyle = cf(this.curve.color);
			ctx.stroke();

			this.listeners.forEach(listener => listener());
		}

		undo(layer, undo) {
			console.log(layer, undo)
		}

		addListener(listener) {
			this.listeners.push(listener);
		}

		getLayerCanvas(layer) {
			return this.layers[layer] && this.layers[layer].canvas;
		}
	}

	class Average {
		constructor(newWeight) {
			this.newWeight = newWeight;
		}

		reset() {
			this.value = null;
		}

		addValue(value) {
			this.value = (this.value || value) * (1 - this.newWeight) + value * this.newWeight;
			return this.value;
		}
	}

	class CanvasPanel {
		constructor(parentCanvas, x, y, width, height) {
			this.canvas = document.createElement('canvas');
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.canvas.width = width;
			this.canvas.height = height;
			this.ctx = this.canvas.getContext('2d');

			this.addTouchListeners(parentCanvas);
			this.addMouseListeners(parentCanvas);

			this.init();
		}

		addTouchListeners(parentCanvas) {
			this.touch = false;

			parentCanvas.addEventListener('touchstart', e => {
				this.touch = this.readTouch(e);
				if (this.touch)
					this.touchStart(this.touch);
			});

			parentCanvas.addEventListener('touchmove', e => {
				if (!this.touch)
					return;

				this.touch = this.readTouch(e);
				if (this.touch)
					this.touchMove(this.touch);
				else
					this.touchEnd();
			});

			parentCanvas.addEventListener('touchend', e => {
				if (this.touch)
					this.touchEnd();
				this.touch = null;
			});
		}

		addMouseListeners(parentCanvas) {
			this.mouseDown = false;

			parentCanvas.addEventListener('mousedown', e => {
				this.mouseDown = this.readMouse(e);
				if (this.mouseDown)
					this.touchStart(this.mouseDown);
			});

			parentCanvas.addEventListener('mousemove', e => {
				if (!this.mouseDown)
					return;

				this.mouseDown = this.readMouse(e);
				if (this.mouseDown)
					this.touchMove(this.mouseDown);
				else
					this.touchEnd();
			});

			parentCanvas.addEventListener('mouseup', e => {
				if (this.mouseDown)
					this.touchEnd();
				this.mouseDown = null;
			});
		}

		init() {
			// override
		}

		readTouch(e) {
			e.preventDefault();
			let {clientX: x, clientY: y, radiusX: w, radiusY: h} = e.touches[0];
			x -= this.x + e.srcElement.offsetLeft;
			y -= this.y + e.srcElement.offsetTop;
			if (x > 0 && x < this.width && y > 0 && y < this.height)
				return {x, y, w, h};
		}

		readMouse(e) {
			e.preventDefault();
			let {clientX: x, clientY: y, altKey, ctrlKey, shiftKey} = e;
			x -= this.x + e.srcElement.offsetLeft;
			y -= this.y + e.srcElement.offsetTop;
			let fakeSize = 2 + (altKey + ctrlKey + shiftKey) / 3;
			if (x > 0 && x < this.width && y > 0 && y < this.height)
				return {x, y, w: fakeSize, h: 0};
		}

		touchStart(touch) {
			// override
		}

		touchMove(touch) {
			// override
		}

		touchEnd() {
			// override
		}

		draw(ctx) {
			ctx.drawImage(this.canvas, this.x, this.y);
		}

		addOutline(outlinePath) {
			let x = this.x || 1;
			let y = this.y || 1;
			let w = this.width - !this.x - (this.x + this.width === canvas.width);
			let h = this.height - !this.y - (this.y + this.height === canvas.height);
			outlinePath.rect(x, y, w, h);
		}
	}

	class DrawPanel extends CanvasPanel {
		lastTouches(n) {
			return this.touches.slice(this.touches.length - n);
		}

		touchStart(touch) {
			curves.beginCurve();
			curves.continueCurve(touch);
			this.paint();
		}

		touchMove(touch) {
			curves.continueCurve(touch);
			this.paint();
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			curves.layers.forEach(({canvas}) => this.ctx.drawImage(canvas, 0, 0));
		}
	}

	class ColorPanel extends CanvasPanel {
		init() {
			this.margin = 10;
			this.size = Math.min(this.width, this.height) - this.margin * 2;
			this.barHeight = 40;
			this.brightnessBarTop = this.size + this.margin * 2;
			this.alphaBarTop = this.brightnessBarTop + this.barHeight + this.margin;
			this.selectionSquareTop = this.alphaBarTop + this.barHeight + this.margin;

			this.rx = Math.cos(0) + .5;
			this.ry = Math.sin(0) + .5;
			this.gx = Math.cos(Math.PI * 2 / 3) + .5;
			this.gy = Math.sin(Math.PI * 2 / 3) + .5;
			this.bx = Math.cos(Math.PI * 4 / 3) + .5;
			this.by = Math.sin(Math.PI * 4 / 3) + .5;

			this.brightness = .5;
			this.alpha = 1;
			this.circleX = this.circleY = .5;
			this.setColor(this.colorAt());
			this.paint();
		}

		touchStart(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		touchMove(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		colorAt(xf = this.circleX, yf = this.circleY) {
			let radius = dist(xf, yf, .5, .5);

			if (radius > .5)
				return;

			let r = 1 + this.brightness - dist(xf, yf, this.rx, this.ry);
			let g = 1 + this.brightness - dist(xf, yf, this.gx, this.gy);
			let b = 1 + this.brightness - dist(xf, yf, this.bx, this.by);
			return {r, g, b, a: this.alpha};
		}

		setColor(color) {
			this.color = color;
			curves.setColor(color);
		}

		pick(x, y) {
			this.pickColor(x, y);
			this.pickBrightness(x, y);
			this.pickAlpha(x, y);
			this.setColor(this.colorAt() || this.color);
		}

		pickColor(x, y) {
			let xf = (x - this.margin) / this.size;
			let yf = (y - this.margin) / this.size;
			if (this.colorAt(xf, yf)) {
				this.circleX = xf;
				this.circleY = yf;
			}
		}

		pickBrightness(x, y) {
			let xf = (x - this.margin) / this.size;
			let yf = (y - this.brightnessBarTop) / this.barHeight;

			if (xf > 0 && xf < 1 && yf > 0 && yf < 1)
				this.brightness = xf;
		}

		pickAlpha(x, y) {
			let xf = (x - this.margin) / this.size;
			let yf = (y - this.alphaBarTop) / this.barHeight;

			if (xf > 0 && xf < 1 && yf > 0 && yf < 1)
				this.alpha = xf;
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			this.paintColor();
			this.paintBrightness();
			this.paintAlpha();
			this.paintPreview();
		}

		paintColor() {
			for (let x = 0; x < this.size; x++)
				for (let y = 0; y < this.size; y++) {
					let xf = x / this.size, yf = y / this.size;
					let c = this.colorAt(xf, yf);
					if (!c)
						continue;
					let selected = Math.abs(xf - this.circleX) < .02 && Math.abs(yf - this.circleY) < .02;
					this.ctx.fillStyle = selected ? cfu(1) : cf(c);
					this.ctx.fillRect(x + this.margin, y + this.margin, 1, 1);
				}
		}

		paintBrightness() {
			for (let x = 0; x < this.size; x++) {
				let xf = x / this.size;

				this.ctx.fillStyle = cfu(xf);
				this.ctx.fillRect(x + this.margin, this.brightnessBarTop, 1, this.barHeight);
			}

			this.paintBarSelectionAndOutline(this.brightnessBarTop, this.brightness);
		}

		paintAlpha() {
			this.paintCheckBackground(this.margin, this.alphaBarTop, this.size, this.barHeight);

			for (let x = 0; x < this.size; x++) {
				let xf = x / this.size;

				this.ctx.fillStyle = cfu(0, xf);
				this.ctx.fillRect(x + this.margin, this.alphaBarTop, 1, this.barHeight);
			}

			this.paintBarSelectionAndOutline(this.alphaBarTop, this.alpha);
		}

		paintPreview() {
			const SIZE = this.size / 3;
			let left = this.margin + SIZE;

			this.paintCheckBackground(left, this.selectionSquareTop, SIZE, SIZE);

			this.ctx.fillStyle = cf(this.color);
			this.ctx.fillRect(left, this.selectionSquareTop, SIZE, SIZE);

			this.ctx.strokeStyle = cfu(.5);
			this.ctx.strokeRect(left, this.selectionSquareTop, SIZE, SIZE);
		}

		paintBarSelectionAndOutline(barTop, selection) {
			let selectionLeft = Math.max(selection - .02, 0);
			let selectionWidth = Math.min(selection + .02, 1) - selectionLeft;
			this.ctx.fillStyle = cfu(1);
			this.ctx.fillRect(selectionLeft * this.size + this.margin, barTop, selectionWidth * this.size, this.barHeight);
			this.ctx.strokeStyle = cfu(.5);
			this.ctx.strokeRect(selectionLeft * this.size + this.margin, barTop, selectionWidth * this.size, this.barHeight);

			this.ctx.strokeRect(this.margin, barTop, this.size, this.barHeight);
		}

		paintCheckBackground(left, top, width, height) {
			const square = 10;
			for (let x = 0; x < width / square; x++)
				for (let y = 0; y < height / square; y++) {
					let black = (x + y) % 2;
					this.ctx.fillStyle = black ? cfu(0) : cfu(1);
					let w = Math.min(square, width - x * square);
					let h = Math.min(square, height - y * square);
					this.ctx.fillRect(x * square + left, y * square + top, w, h);
				}
		}
	}

	class LayerPanel extends CanvasPanel {
		init() {
			this.margin = 10;
			this.barWidth = this.width - this.margin * 2;
			this.barHeight = this.barWidth;
			this.deltaY = this.barHeight + this.margin;

			this.layerCount = LAYER_COUNT;
			this.setLayer(0);
			this.paint();

			curves.addListener(() => this.paint());
		}

		setLayer(layer) {
			this.layer = layer;
			curves.setLayer(layer);
		}

		touchStart(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		pick(x, y) {
			let xf = (x - this.margin) / this.barWidth;
			let yf = (y - this.margin) / this.deltaY;
			if (xf > 0 && xf < 1 && yf > 0 && yf % 1 < this.barHeight / this.deltaY && yf < this.layerCount)
				this.setLayer(yf - yf % 1);
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			for (let i = 0; i < this.layerCount; i++) {
				if (i === this.layer)
					this.ctx.strokeStyle = cfu(0);
				else
					this.ctx.strokeStyle = cfu(.6);
				if (curves.getLayerCanvas(i))
					this.ctx.drawImage(curves.getLayerCanvas(i), this.margin, i * this.deltaY + this.margin, this.barWidth, this.barHeight);
				this.ctx.strokeRect(this.margin, i * this.deltaY + this.margin, this.barWidth, this.barHeight);
			}
		}
	}

	class HistoryPanel extends CanvasPanel {
		init() {
			// todo share with layer panel
			this.margin = 10;
			this.barWidth = this.width - this.margin * 2;
			this.barHeight = this.barWidth;
			this.deltaY = this.barHeight + this.margin;

			this.layerCount = LAYER_COUNT;
			this.paint();

			curves.addListener(() => this.paint());
		}

		touchStart(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		pick(x, y) {
			let xf = (x - this.margin) / this.barWidth;
			let yf = (y - this.margin) / this.deltaY;
			if (xf > 0 && xf < 1 && yf > 0 && yf % 1 < this.barHeight / this.deltaY && yf < this.layerCount)
				curves.undo(yf - yf % 1, yf % 1 < .5);
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			this.ctx.strokeStyle = cfu(.6);
			this.ctx.fillStyle = cfu(.4);

			for (let i = .0; i < this.layerCount; i++) {
				// rect outline
				this.ctx.strokeRect(this.margin, i * this.deltaY + this.margin, this.barWidth, this.barHeight);

				// middle separator
				this.ctx.beginPath();
				this.ctx.moveTo(this.margin, i * this.deltaY + this.margin + this.barHeight / 2);
				this.ctx.lineTo(this.margin + this.barWidth, i * this.deltaY + this.margin + this.barHeight / 2);
				this.ctx.stroke();

				// icons
				this.ctx.font = '30px Arial';
				this.ctx.textBaseline = 'top';
				let topTextY = i * this.deltaY - fontHeight(this.ctx) / 2 + this.margin + this.barHeight / 4;
				this.ctx.fillText('<', this.margin * 2, topTextY);
				this.ctx.fillText('>', this.margin * 2, topTextY + this.barHeight / 2);
			}
		}
	}

	const canvas = $('canvas');
	const ctx = canvas.getContext('2d');

	let curves = new Curves(800, 800);

	let drawPanel = new DrawPanel(canvas, 0, 0, 800, 800);
	let colorPanel = new ColorPanel(canvas, 800, 0, 200, 800);
	let layerPanel = new LayerPanel(canvas, 1000, 0, 100, 800);
	let historyPanel = new HistoryPanel(canvas, 1100, 0, 100, 800);
	let panels = [drawPanel, colorPanel, layerPanel, historyPanel];

	let outline = new Path2D();
	panels.forEach(panel => panel.addOutline(outline));
	outline.rect(1, 1, canvas.width - 2, canvas.height - 2);

	let render = () => {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		panels.forEach(panel => panel.draw(ctx));
		ctx.strokeStyle = cfu(.6);
		ctx.stroke(outline);
		requestAnimationFrame(render);
	};
	render();

	// todo
	// recent colors
	// undo/redo
	// save
	// line width, brush style
	// touch tap to draw small rect
	// more accuracy and drag movement with key modifiers
	// zoom
	// tools such as move, copy, rotate
	// dim layers on top of selected layer
</script>
