<canvas width="1000" height="800"></canvas>

<script>
	const $ = document.querySelector.bind(document);
	const c255 = (r, g, b) => `rgb(${r},${g},${b})`;
	const cf = ({r, g, b}) => `rgb(${r * 255},${g * 255},${b * 255})`;
	const cfu = (v) => `rgb(${v * 255},${v * 255},${v * 255})`;
	const dist = (x, y, x2, y2) => Math.sqrt((x - x2) ** 2 + (y - y2) ** 2);
	const scale = (v, min, max) => Math.min(Math.max((v - min) / (max - min), 0), 1);

	class Average {
		constructor(newWeight) {
			this.newWeight = newWeight;
		}

		reset() {
			this.value = null;
		}

		addValue(value) {
			this.value = (this.value || value) * (1 - this.newWeight) + value * this.newWeight;
			return this.value;
		}
	}

	class CanvasPanel {
		constructor(parentCanvas, x, y, width, height) {
			this.canvas = document.createElement('canvas');
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.canvas.width = width;
			this.canvas.height = height;
			this.ctx = this.canvas.getContext('2d');

			this.touch = false;
			parentCanvas.addEventListener('touchstart', e => {
				this.touch = this.readTouch(e);
				if (this.touch)
					this.touchStart(this.touch);
			});
			parentCanvas.addEventListener('touchmove', e => {
				if (!this.touch)
					return;

				this.touch = this.readTouch(e);
				if (this.touch)
					this.touchMove(this.touch);
				else
					this.touchEnd();
			});
			parentCanvas.addEventListener('touchend', e => {
				if (this.touch)
					this.touchEnd();
			});

			this.init();
		}

		init() {
			// override
		}

		readTouch(e) {
			e.preventDefault(); // todo move
			let {clientX: x, clientY: y, radiusX: w, radiusY: h} = e.touches[0];
			x -= this.x;
			y -= this.y;
			if (x > 0 && x < this.width && y > 0 && y < this.height)
				return {x, y, w, h};
		}

		touchStart(touch) {
			// override
		}

		touchMove(touch) {
			// override
		}

		touchEnd() {
			// override
		}

		draw(ctx) {
			ctx.drawImage(this.canvas, this.x, this.y);
		}
	}

	class DrawPanel extends CanvasPanel {
		init() {
			this.n = 4;
			this.touches = [];
			this.pressure = new Average(.3);
		}

		setGetColorFunc(getColor) {
			this.getColor = getColor
		};

		lastTouches(n) {
			return this.touches.slice(this.touches.length - n);
		}

		touchStart(touch) {
			this.touches = [touch];
			this.pressure.reset();
		}

		touchMove(touch) {
			this.touches.push(touch);

			if (this.touches.length < this.n)
				return;
			let ts = this.lastTouches(this.n);

			let pressure = ts.reduce((a, {w, h}) => a + w + h, 0) / ts.length;
			let avgPressure = this.pressure.addValue(pressure);
			let scaledPressure = scale(avgPressure, 2, 3);
			let width = scaledPressure ** 2 * 10 + 1;

			this.ctx.lineWidth = width;
			this.ctx.beginPath();
			this.ctx.moveTo(ts[0].x, ts[0].y);
			this.ctx.bezierCurveTo(ts[1].x, ts[1].y, ts[2].x, ts[2].y, ts[3].x, ts[3].y);
			this.ctx.strokeStyle = this.getColor();
			this.ctx.stroke();
		}

		touchEnd() {
			if (this.touches.length >= this.n)
				return;
			let t = this.lastTouches(1)[0];

			this.ctx.lineWidth = (t.w + t.h) ** 2;
			this.ctx.strokeStyle = this.getColor();
			this.ctx.strokeRect(t.x, t.y, t.w, t.h);
		}
	}

	class ColorPanel extends CanvasPanel {
		init() {
			this.margin = 10;
			this.size = Math.min(this.width, this.height) - this.margin * 2;
			this.brightnessBarHeight = 60;
			this.brightnessBarTop = this.size + this.margin * 2;
			this.selectionSquareTop = this.brightnessBarTop + this.brightnessBarHeight + this.margin;

			this.rx = Math.cos(0) + .5;
			this.ry = Math.sin(0) + .5;
			this.gx = Math.cos(Math.PI * 2 / 3) + .5;
			this.gy = Math.sin(Math.PI * 2 / 3) + .5;
			this.bx = Math.cos(Math.PI * 4 / 3) + .5;
			this.by = Math.sin(Math.PI * 4 / 3) + .5;

			this.brightness = .5;
			this.circleX = this.circleY = .5;
			this.color = this.colorAt();
			this.paint();
		}

		touchStart(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		touchMove(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		colorAt(xf = this.circleX, yf = this.circleY) {
			let radius = dist(xf, yf, .5, .5);

			if (radius > .5)
				return;

			let r = 1 + this.brightness - dist(xf, yf, this.rx, this.ry);
			let g = 1 + this.brightness - dist(xf, yf, this.gx, this.gy);
			let b = 1 + this.brightness - dist(xf, yf, this.bx, this.by);
			return {r, g, b};
		}

		pick(x, y) {
			this.pickColor(x, y);
			this.pickBrightness(x, y);
			this.color = this.colorAt() || this.color;
		}

		pickColor(x, y) {
			let xf = (x - this.margin) / this.size;
			let yf = (y - this.margin) / this.size;
			if (this.colorAt(xf, yf)) {
				this.circleX = xf;
				this.circleY = yf;
			}
		}

		pickBrightness(x, y) {
			let xf = (x - this.margin) / this.size;
			let yf = (y - this.brightnessBarTop) / this.brightnessBarHeight;

			if (xf > 0 && xf < 1 && yf > 0 && yf < 1)
				this.brightness = xf;
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			this.paintCircle();
			this.paintBar();
			this.paintSquare();
		}

		paintCircle() {
			for (let x = 0; x < this.size; x++)
				for (let y = 0; y < this.size; y++) {
					let xf = x / this.size, yf = y / this.size;
					let c = this.colorAt(xf, yf);
					if (Math.abs(xf - this.circleX) < .02 && Math.abs(yf - this.circleY) < .02) {
						this.ctx.fillStyle = cfu(1);
						this.ctx.fillRect(x + this.margin, y + this.margin, 1, 1);
					} else if (c) {
						this.ctx.fillStyle = cf(c);
						this.ctx.fillRect(x + this.margin, y + this.margin, 1, 1);
					}
				}
		}

		paintBar() {
			for (let x = 0; x < this.size; x++) {
				let xf = x / this.size;

				let selected = Math.abs(xf - this.brightness) < .02;

				this.ctx.fillStyle = cfu(xf);
				this.ctx.fillRect(x + this.margin, this.brightnessBarTop, 1, this.brightnessBarHeight - selected * .2 * this.brightnessBarHeight);
			}
			this.ctx.lineWidth = .5;
			this.ctx.strokeRect(this.margin, this.brightnessBarTop, this.size, this.brightnessBarHeight);
		}

		paintSquare() {
			this.ctx.fillStyle = cf(this.color);
			this.ctx.fillRect(this.margin + this.size / 3, this.selectionSquareTop, this.size / 3, this.size / 3);
		}
	}

	class LayerPanel extends CanvasPanel {
		init() {
			this.margin = 10;
			this.barWidth = this.width - this.margin * 2;
			this.barHeight = 60;
			this.deltaY = this.barHeight + this.margin;

			this.layerCount = 5;
			this.selected = 0;
			this.paint();
		}

		touchStart(touch) {
			this.pick(touch.x, touch.y);
			this.paint();

		}

		pick(x, y) {
			let xf = (x - this.margin) / this.barWidth;
			let yf = (y - this.margin) / this.deltaY;
			if (xf > 0 && xf < 1 && yf > 0 && yf % 1 < this.barHeight / this.deltaY && yf < this.layerCount)
				this.selected = yf - yf % 1;
		}

		paint() {
			this.ctx.clearRect(0, 0, this.width, this.height);
			this.ctx.fillStyle = cfu(.9);
			for (let i = 0; i < this.layerCount; i++) {
				if (i === this.selected)
					this.ctx.fillRect(this.margin, i * this.deltaY + this.margin, this.barWidth, this.barHeight);
				this.ctx.strokeRect(this.margin, i * this.deltaY + this.margin, this.barWidth, this.barHeight);
			}
		}
	}

	const canvas = $('canvas');
	const ctx = canvas.getContext('2d');

	let drawPanel = new DrawPanel(canvas, 0, 0, 800, 800);
	let colorPanel = new ColorPanel(canvas, 800, 0, 200, 340);
	let layerPanel = new LayerPanel(canvas, 800, 340, 200, 800 - 340);
	drawPanel.setGetColorFunc(() => cf(colorPanel.color));
	let panels = [drawPanel, colorPanel, layerPanel];

	let outline = new Path2D();
	outline.moveTo(panels[0].width, 0);
	outline.lineTo(panels[0].width, canvas.height);
	outline.moveTo(panels[1].x, panels[1].height);
	outline.lineTo(panels[1].x + panels[1].width, panels[1].height);
	outline.rect(1, 1, canvas.width - 2, canvas.height - 2);

	let render = () => {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		panels.forEach(panel => panel.draw(ctx));
		ctx.lineWidth = .7;
		ctx.stroke(outline);
		requestAnimationFrame(render);
	};
	render();

	// todo
	// each panel responsible for outlines
	// layers
	// recent colors
	// color transparency
	// undo/redo
	// save
	// line width, brush style
</script>
